<!doctype html>
<notebook theme="air">
  <title>WebGPU Instanced Lines</title>
  <script id="1" type="module">
    const link = html`<a href="https://github.com/rreusser/webgpu-instanced-lines" target="_blank" style="
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #24292e;
      color: white;
      border-radius: 6px;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      float: right;
      margin: 0 0 10px 10px;
    ">
      <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
      View on GitHub
    </a>`;
    display(link);
  </script>
  <script id="1b" type="text/markdown">
    # WebGPU Instanced Lines

    High-performance, flexible GPU-accelerated line rendering for WebGPU. This is a direct port of [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines) to WebGPU. The focus is on speed and customizability rather than sophisticated stroke expansion algorithms. Drag handles to edit vertices, drag the background to pan, and scroll to zoom. Enable **Debug view** to see the underlying triangle strip structure.
  </script>
  <script id="2" type="module">
    // Initialize WebGPU for interactive demo
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="module">
    // Initialize offscreen demo renderer for static examples
    import { initDemoRenderer } from './lib/demo-renderer.js';

    const demoRenderer = await initDemoRenderer();
    invalidation.then(() => demoRenderer.destroy());
  </script>
  <script id="4" type="text/markdown">
  </script>
  <script id="5" type="module">
    import { createElementStack } from './lib/element-stack.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'

    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    const renderState = { dirty: true };

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => {
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption>Drag handles to edit vertices. Drag background to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: canvasWidth,
      height: canvasHeight,
      controls: '.lines-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          d3.scaleLinear().domain([-1, 1]).range([0, w]),
          d3.scaleLinear().domain([-1, 1]).range([h, 0])
        );
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    }));
  </script>
  <script id="6" type="module">
    const lineWidthInput = Inputs.range([1, 100], { label: 'Line width', value: 50, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const capTypeInput = Inputs.select(['round', 'square', 'butt'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const sdfStrokeWidthInput = Inputs.range([0, 50], { label: 'SDF stroke width', value: 10, step: 0.5 });
    const sdfStrokeWidth = view(sdfStrokeWidthInput);

    const alphaInput = Inputs.range([0, 1], { label: 'Alpha', value: 1, step: 0.01 });
    const alpha = view(alphaInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    const stripesInput = Inputs.toggle({ label: 'Stripes', value: false });
    const stripes = view(stripesInput);

    const varyingWidthInput = Inputs.toggle({ label: 'Varying width', value: false });
    const varyingWidth = view(varyingWidthInput);

    const debugViewInput = Inputs.toggle({ label: 'Debug view', value: 'Debug view' });
    const debugView = view(debugViewInput);

    const depthTestInput = Inputs.toggle({ label: 'Depth test' });
    const depthTest = view(depthTestInput);

    const cullBackFacesInput = Inputs.toggle({ label: 'Cull back faces' });
    const cullBackFaces = view(cullBackFacesInput);
  </script>
  <script id="7" type="module">
    const miterLimitInput = Inputs.range([1, 10], {
      label: 'Miter limit',
      value: 4,
      step: 0.1,
      disabled: joinType !== 'miter'
    });
    const miterLimit = view(miterLimitInput);
  </script>
  <script id="8" type="module">
    const joinResolutionInput = Inputs.range([2, 16], {
      label: 'Round join resolution',
      value: 8,
      step: 1,
      disabled: joinType !== 'round'
    });
    const joinResolution = view(joinResolutionInput);
  </script>
  <script id="9" type="module">
    const capResolutionInput = Inputs.range([2, 16], {
      label: 'Round cap resolution',
      value: 8,
      step: 1,
      disabled: capType !== 'round'
    });
    const capResolution = view(capResolutionInput);
  </script>
  <script id="10" type="module">
    display(html`<div class="lines-controls">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfStrokeWidthInput}
      ${alphaInput}
      ${lineBreakInput}
      ${stripesInput}
      ${varyingWidthInput}
      ${debugViewInput}
      ${depthTestInput}
      ${cullBackFacesInput}
    </div>`);
  </script>
  <script id="11" type="module">
    import { createGPULines } from '../dist/webgpu-instanced-lines.esm.js';

    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push({ x: r * Math.cos(angle), y: r * Math.sin(angle), z: 0, w: 1 });
        }
      } else {
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      }

      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, { x: 0, y: 0, z: 0, w: 0 });
      }

      return basePoints;
    }

    const points = generatePattern(pattern, lineBreak);
    const numPoints = points.length;

    function pointsToFloat32Array(pts) {
      const arr = new Float32Array(pts.length * 4);
      for (let i = 0; i < pts.length; i++) {
        arr[i * 4 + 0] = pts[i].x;
        arr[i * 4 + 1] = pts[i].y;
        arr[i * 4 + 2] = pts[i].z;
        arr[i * 4 + 3] = pts[i].w;
      }
      return arr;
    }

    // Compute cumulative distance along the line
    function computeDistances(pts) {
      const distances = new Float32Array(pts.length);
      let cumDist = 0;
      for (let i = 0; i < pts.length; i++) {
        if (pts[i].w === 0) {
          // Line break - reset distance
          cumDist = 0;
        } else if (i > 0 && pts[i - 1].w !== 0) {
          const dx = pts[i].x - pts[i - 1].x;
          const dy = pts[i].y - pts[i - 1].y;
          cumDist += Math.sqrt(dx * dx + dy * dy);
        }
        distances[i] = cumDist;
      }
      return distances;
    }

    const positions = pointsToFloat32Array(points);
    const distances = computeDistances(points);
    const totalDistance = Math.max(...distances);

    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    const distanceBuffer = device.createBuffer({
      label: 'line-distances',
      size: distances.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(distanceBuffer, 0, distances);

    const totalDistanceBuffer = device.createBuffer({
      label: 'total-distance',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([totalDistance]));

    function updateBuffers() {
      const newPositions = pointsToFloat32Array(points);
      const newDistances = computeDistances(points);
      const newTotalDistance = Math.max(...newDistances);
      device.queue.writeBuffer(positionBuffer, 0, newPositions);
      device.queue.writeBuffer(distanceBuffer, 0, newDistances);
      device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([newTotalDistance]));
      renderState.dirty = true;
    }

    invalidation.then(() => {
      positionBuffer.destroy();
      distanceBuffer.destroy();
      totalDistanceBuffer.destroy();
    });
  </script>
  <script id="12" type="module">
    const svg = d3.select(stack.elements.svg);

    const editablePoints = points.map((p, i) => ({ point: p, index: i }))
                                 .filter(d => d.point.w !== 0);

    // Use groups with invisible hit area + visible circle
    const handleGroups = svg.selectAll('g.vertex-handle')
      .data(editablePoints, d => d.index)
      .join('g')
      .attr('class', 'vertex-handle')
      .attr('cursor', 'move')
      .call(d3.drag()
        .on('start', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#0066cc').attr('stroke-width', 2);
        })
        .on('drag', function(event, d) {
          d.point.x = axes.xScale.invert(event.x);
          d.point.y = axes.yScale.invert(event.y);
          d3.select(this).attr('transform', `translate(${event.x},${event.y})`);
          updateBuffers();
        })
        .on('end', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#333').attr('stroke-width', 1.5);
        })
      );

    // Invisible hit area (larger)
    handleGroups.append('circle')
      .attr('class', 'hit-area')
      .attr('r', 20)
      .attr('fill', 'transparent');

    // Visible circle (smaller)
    handleGroups.append('circle')
      .attr('class', 'visible')
      .attr('r', 5)
      .attr('fill', 'white')
      .attr('stroke', '#333')
      .attr('stroke-width', 1.5)
      .attr('pointer-events', 'none');

    function updateHandlePositions() {
      handleGroups.attr('transform', d =>
        `translate(${axes.xScale(d.point.x)},${axes.yScale(d.point.y)})`);
    }

    updateHandlePositions();
    stack.addEventListener('update', updateHandlePositions);
  </script>
  <script id="13" type="module">
    // Only depend on shader-affecting parameters (join/cap type, shader options)
    // Resolution and miterLimit are now runtime parameters passed to draw()
    joinType; capType; sdfStrokeWidth; alpha; stripes; varyingWidth; debugView; depthTest; cullBackFaces;

    const useSdfMode = sdfStrokeWidth > 0;
    const useBlend = useSdfMode || alpha < 1 || debugView;
    const depthFormat = depthTest ? 'depth24plus' : null;

    // Vertex shader body with position buffer, distance buffer, and view matrix
    const vertexShaderBody = /* wgsl */`
      @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
      @group(1) @binding(1) var<storage, read> distances: array<f32>;
      @group(1) @binding(2) var<uniform> viewMatrix: mat4x4f;
      @group(1) @binding(3) var<uniform> totalDistance: f32;
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;
      @group(1) @binding(5) var<uniform> lineWidthUniform: f32;

      struct Vertex {
        position: vec4f,
        width: f32,
        dist: f32,      // cumulative distance along line
        lineWidth: f32, // interpolated width for fragment shader
      }

      fn getVertex(index: u32) -> Vertex {
        let p = positions[index];
        let d = distances[index];
        let projected = viewMatrix * vec4f(p.xyz, 1.0);
        // Reference totalDistance to ensure it's included in bind group layout
        let normalizedDist = d / totalDistance;
        let w = ${varyingWidth ? 'lineWidthUniform * (0.5 + 1.5 * normalizedDist)' : 'lineWidthUniform'};
        return Vertex(vec4f(projected.xyz, p.w * projected.w), w, d, w);
      }
    `;

    // SDF distance function: round uses length, square uses max(abs)
    const sdfDistFn = capType === 'square'
      ? 'max(abs(lineCoord.x), abs(lineCoord.y))'
      : 'length(lineCoord.xy)';

    // Unified fragment shader handling all modes
    const fragmentShaderBody = /* wgsl */`
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;

      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }

      // Unit grid lines for wireframe
      fn grid(parameter: vec3f, width: f32, feather: f32) -> f32 {
        let w1 = width - feather * 0.5;
        let d = fwidth(parameter);
        let looped = 0.5 - abs(parameter % 1.0 - 0.5);
        let a3 = smoothstep(d * w1, d * (w1 + feather), looped);
        return min(min(a3.x, a3.y), a3.z);
      }

      fn getColor(lineCoord: vec2f, dist: f32, lineWidth: f32, instanceID: f32, triStripCoord: vec2f) -> vec4f {
        let strokeWidth = ${sdfStrokeWidth.toFixed(1)} * debug.dpr;
        let baseAlpha = ${alpha.toFixed(2)};

        // Compute SDF values
        let sdf = 0.5 * lineWidth * ${sdfDistFn};
        let aa = select(baseAlpha, linearstep(lineWidth * 0.5, lineWidth * 0.5 - 1.0, sdf) * baseAlpha, strokeWidth > 0.0);
        let strokeMask = select(0.0, linearstep(lineWidth * 0.5 - strokeWidth - 0.5, lineWidth * 0.5 - strokeWidth + 0.5, sdf), strokeWidth > 0.0);

        // Layer 1: Base fill color (debug instance color or normal color)
        var baseColor: vec3f;
        if (debug.enabled == 1u) {
          // instanceID encodes: non-negative = segment index, negative = cap with index (-id - 1)
          let isCap = instanceID < 0.0;
          let segmentIndex = select(instanceID, -instanceID - 1.0, isCap);
          let iSegmentIndex = i32(floor(segmentIndex + 0.5));
          baseColor = select(vec3f(0.8, 0.1, 0.4), vec3f(0.1, 0.7, 1.0), iSegmentIndex % 2 == 0);
        } else {
          baseColor = vec3f(0.1, 0.7, 1.0);
        }

        // Layer 2: Apply stripes on top of base color
        let stripeFreq = 20.0;
        let stripe = step(0.5, fract(dist * stripeFreq));
        let stripeColor = baseColor * 0.4;  // Darker version of base
        var color = ${stripes ? 'mix(baseColor, stripeColor, stripe)' : 'baseColor'};

        // Layer 3: Apply stroke (50% black in debug mode, dark blue in normal mode)
        color = mix(color, vec3f(0.0), strokeMask * 0.7);

        // Layer 4: Wireframe gridlines (debug only)
        if (debug.enabled == 1u) {
          let wire = grid(vec3f(triStripCoord, triStripCoord.x + triStripCoord.y), 0.5 * debug.dpr, 1.0);
          color = mix(vec3f(1.0), color, wire);
        }

        return vec4f(color, aa);
      }
    `;

    // Use max resolutions at init time to allow runtime adjustment up to these values
    // Runtime values (miterLimit, joinResolution, capResolution) are passed to draw()
    const blend = useBlend ? {
      color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
    } : undefined;

    const gpuLines = createGPULines(device, {
      colorTargets: blend ? { format: canvasFormat, blend } : { format: canvasFormat },
      depthStencil: depthFormat ? {
        format: depthFormat,
        depthWriteEnabled: true,
        depthCompare: 'less'
      } : undefined,
      primitive: { cullMode: cullBackFaces ? 'back' : 'none' },
      join: joinType,
      maxJoinResolution: 16,  // Allow up to 16 at runtime
      maxCapResolution: 16,   // Allow up to 16 at runtime
      cap: capType,
      vertexShaderBody,
      fragmentShaderBody,
    });

    // Create view matrix buffer
    const viewMatrixBuffer = device.createBuffer({
      label: 'view-matrix',
      size: 64, // mat4x4f
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create debug uniform buffer (8 bytes: u32 enabled + f32 dpr)
    const debugBuffer = device.createBuffer({
      label: 'debug-uniform',
      size: 8,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create line width uniform buffer
    const lineWidthBuffer = device.createBuffer({
      label: 'line-width-uniform',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create bind group for user data (group 1)
    const dataBindGroup = device.createBindGroup({
      layout: gpuLines.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: { buffer: positionBuffer } },
        { binding: 1, resource: { buffer: distanceBuffer } },
        { binding: 2, resource: { buffer: viewMatrixBuffer } },
        { binding: 3, resource: { buffer: totalDistanceBuffer } },
        { binding: 4, resource: { buffer: debugBuffer } },
        { binding: 5, resource: { buffer: lineWidthBuffer } }
      ]
    });

    invalidation.then(() => {
      gpuLines.destroy();
      viewMatrixBuffer.destroy();
      lineWidthBuffer.destroy();
      debugBuffer.destroy();
    });
  </script>
  <script id="14" type="module">
    import { createFrameLoop } from './lib/frame-loop.js';

    // Depend on runtime parameters that don't require pipeline recreation
    lineWidth; debugView; miterLimit; joinResolution; capResolution; renderState.dirty = true;

    // Depth texture for depth testing (created lazily, resized as needed)
    let depthTexture = null;
    let depthTextureWidth = 0;
    let depthTextureHeight = 0;

    const loop = createFrameLoop(() => {
      if (renderState.dirty) {
        // Update view matrix buffer
        device.queue.writeBuffer(viewMatrixBuffer, 0, axes.view);

        // Update debug uniform (enabled: u32, dpr: f32)
        const debugData = new ArrayBuffer(8);
        new Uint32Array(debugData, 0, 1)[0] = debugView ? 1 : 0;
        new Float32Array(debugData, 4, 1)[0] = dpr;
        device.queue.writeBuffer(debugBuffer, 0, debugData);

        // Update line width uniform
        device.queue.writeBuffer(lineWidthBuffer, 0, new Float32Array([lineWidth * dpr]));

        // Create/resize depth texture if depth testing is enabled
        if (depthFormat) {
          if (!depthTexture || depthTextureWidth !== canvas.width || depthTextureHeight !== canvas.height) {
            if (depthTexture) depthTexture.destroy();
            depthTexture = device.createTexture({
              size: [canvas.width, canvas.height],
              format: depthFormat,
              usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            depthTextureWidth = canvas.width;
            depthTextureHeight = canvas.height;
          }
        }

        const encoder = device.createCommandEncoder();

        const renderPassDescriptor = {
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1 }
          }]
        };

        // Add depth attachment if depth testing is enabled
        if (depthFormat && depthTexture) {
          renderPassDescriptor.depthStencilAttachment = {
            view: depthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: 'clear',
            depthStoreOp: 'store'
          };
        }

        const pass = encoder.beginRenderPass(renderPassDescriptor);

        // Pass runtime parameters (miterLimit, joinResolution, capResolution)
        // These update uniforms without recreating the pipeline
        gpuLines.draw(pass, {
          vertexCount: numPoints,
          resolution: [canvas.width, canvas.height],
          miterLimit: miterLimit,
          joinResolution: joinResolution,
          capResolution: capResolution
        }, [dataBindGroup]);

        pass.end();
        device.queue.submit([encoder.finish()]);
        renderState.dirty = false;
      }
    });

    invalidation.then(() => {
      loop.cancel();
      if (depthTexture) depthTexture.destroy();
    });
  </script>
  <script id="14b" type="text/markdown">
    ---

    ## Installation

    ```bash
    npm install webgpu-instanced-lines
    ```

    ## Usage

    ```javascript
    import { createGPULines } from 'webgpu-instanced-lines';

    const gpuLines = createGPULines(device, {
      format: canvasFormat,
      join: 'round',
      cap: 'round',
      vertexShaderBody: /* wgsl */`
        @group(1) @binding(0) var<storage, read> positions: array<vec4f>;

        struct Vertex {
          position: vec4f,
          width: f32,
        }

        fn getVertex(index: u32) -> Vertex {
          return Vertex(positions[index], 10.0);
        }
      `,
      fragmentShaderBody: /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          return vec4f(0.2, 0.5, 0.9, 1.0);
        }
      `
    });

    // In render loop:
    gpuLines.draw(pass, {
      vertexCount: numPoints,
      resolution: [canvas.width, canvas.height]
    }, [dataBindGroup]);
    ```

    For background on GPU line rendering, see Matt DesLauriers' [Drawing Lines is Hard](https://mattdesl.svbtle.com/drawing-lines-is-hard) and Rye Terrell's [Instanced Line Rendering](https://wwwtyro.net/2019/11/18/instanced-lines.html).
  </script>
  <script id="15" type="module">
    import readmeMd from '../README.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    // Get How It Works section from README, which includes Features and Limitations
    const howItWorks = getSectionWithHeading(readmeMd, 'How It Works', 2);

    // Additional content specific to the docs (Line Breaks, Vertex Window)
    const additionalContent = `
### Line Breaks

To create a line break (splitting one line into multiple segments with separate end caps), have your \`getVertex\` function return a position with \`w = 0\` (or \`NaN\` in any component). The library detects these sentinel values and inserts caps on adjacent segments.

### Vertex Window

Internally, each instance calls \`getVertex\` for a 4-point window of adjacent vertices. Points **A** (previous) and **D** (next) provide direction for computing join angles. Points **B** (start) and **C** (end) define the segment being drawn.

Within each instance, a vertex index (0 to ~30, depending on join/cap resolution) expands into the triangle strip vertices. The vertex shader uses this index to compute screen-space offsets perpendicular to the line direction, forming the segment body, joins, and caps.
`;

    display(md`${howItWorks}

${additionalContent}`);
  </script>
  <script id="16" type="module">
    import apiMd from './API.md?raw';
    import { getSection, getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`---

## API Reference

### \`createGPULines(device, options)\`

${getSection(apiMd, '`createGPULines(device, options)`')}

## Options
`);
  </script>
  <script id="18" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`join`')}`);
  </script>
  <script id="19" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const joinBevel = createDemoCanvas('demo-join-bevel');
      const joinMiter = createDemoCanvas('demo-join-miter');
      const joinRound = createDemoCanvas('demo-join-round');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${joinBevel}
          <figcaption><code>join: 'bevel'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${joinMiter}
          <figcaption><code>join: 'miter'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${joinRound}
          <figcaption><code>join: 'round'</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'join-demo', lineWidth: 50, cap: 'round', miterLimit: 10, width: 200, height: 120 };
      await demoRenderer.renderToCanvas(joinBevel, { ...baseOpts, join: 'bevel' });
      await demoRenderer.renderToCanvas(joinMiter, { ...baseOpts, join: 'miter' });
      await demoRenderer.renderToCanvas(joinRound, { ...baseOpts, join: 'round' });
    }
  </script>
  <script id="20" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`cap`')}`);
  </script>
  <script id="21" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const capRound = createDemoCanvas('demo-cap-round');
      const capSquare = createDemoCanvas('demo-cap-square');
      const capButt = createDemoCanvas('demo-cap-butt');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${capRound}
          <figcaption><code>cap: 'round'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${capSquare}
          <figcaption><code>cap: 'square'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${capButt}
          <figcaption><code>cap: 'butt'</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'cap-demo', lineWidth: 50, width: 200, height: 120 };
      await demoRenderer.renderToCanvas(capRound, { ...baseOpts, cap: 'round' });
      await demoRenderer.renderToCanvas(capSquare, { ...baseOpts, cap: 'square' });
      await demoRenderer.renderToCanvas(capButt, { ...baseOpts, cap: 'butt' });
    }
  </script>
  <script id="22" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`miterLimit`')}`);
  </script>
  <script id="23" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const miter1 = createDemoCanvas('demo-miter-1');
      const miter4 = createDemoCanvas('demo-miter-4');
      const miter10 = createDemoCanvas('demo-miter-10');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${miter1}
          <figcaption><code>miterLimit: 1</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${miter4}
          <figcaption><code>miterLimit: 4</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${miter10}
          <figcaption><code>miterLimit: 10</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'miter-demo', lineWidth: 50, join: 'miter', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(miter1, { ...baseOpts, miterLimit: 1 });
      await demoRenderer.renderToCanvas(miter4, { ...baseOpts, miterLimit: 4 });
      await demoRenderer.renderToCanvas(miter10, { ...baseOpts, miterLimit: 10 });
    }
  </script>
  <script id="24" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`joinResolution` and `capResolution`')}`);
  </script>
  <script id="25" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const res2 = createDemoCanvas('demo-res-2');
      const res4 = createDemoCanvas('demo-res-4');
      const res16 = createDemoCanvas('demo-res-16');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${res2}
          <figcaption><code>joinResolution: 2</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${res4}
          <figcaption><code>joinResolution: 4</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${res16}
          <figcaption><code>joinResolution: 16</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'resolution-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(res2, { ...baseOpts, joinResolution: 2 });
      await demoRenderer.renderToCanvas(res4, { ...baseOpts, joinResolution: 4 });
      await demoRenderer.renderToCanvas(res16, { ...baseOpts, joinResolution: 16 });
    }
  </script>
  <script id="26" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, 'Line Breaks', 3)}`);
  </script>
  <script id="27" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const continuous = createDemoCanvas('demo-continuous');
      const withBreak = createDemoCanvas('demo-with-break');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${continuous}
          <figcaption>Continuous line</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${withBreak}
          <figcaption>With line break (<code>w: 0</code>)</figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'break-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(continuous, { ...baseOpts, lineBreak: false });
      await demoRenderer.renderToCanvas(withBreak, { ...baseOpts, lineBreak: true });
    }
  </script>
  <script id="28" type="module">
    import apiMd from './API.md?raw';
    import { getSection } from './lib/markdown-sections.js';

    // Get just the intro paragraph (content before first ### subsection)
    const customShadersIntro = getSection(apiMd, 'Custom Shaders', 2)
      .split(/^###/m)[0].trim();

    display(md`---

## Custom Shaders

${customShadersIntro}
`);
  </script>
  <script id="29" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`fragmentShaderBody`')}`);
  </script>
  <script id="30" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`lineCoord` Values')}`);
  </script>
  <script id="31" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const lcX = createDemoCanvas('demo-lc-x');
      const lcY = createDemoCanvas('demo-lc-y');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; max-width: 200px;">
          ${lcX}
          <figcaption><code>lineCoord.x</code> (0 on segments, varies in caps)</figcaption>
        </figure>
        <figure style="margin: 0; max-width: 200px;">
          ${lcY}
          <figcaption><code>lineCoord.y</code> (across line)</figcaption>
        </figure>
      </div>`);

      const shaderX = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          // lineCoord.x is 0 for segments, varies in caps (sin(theta))
          let t = abs(lineCoord.x);
          // Blue for segments (x=0), orange gradient in caps
          return vec4f(t, 0.4 * (1.0 - t), 1.0 - t, 1.0);
        }
      `;

      const shaderY = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          let t = lineCoord.y * 0.5 + 0.5;
          return vec4f(t, 0.3, 1.0 - t, 1.0);
        }
      `;

      const baseOpts = { pattern: 'cap-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(lcX, { ...baseOpts, fragmentShaderBody: shaderX });
      await demoRenderer.renderToCanvas(lcY, { ...baseOpts, fragmentShaderBody: shaderY });
    }
  </script>
  <script id="32" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, 'Example Shaders')}`);
  </script>
  <script id="33" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const stripes = createDemoCanvas('demo-stripes');
      const gradient = createDemoCanvas('demo-gradient');
      const sdfStroke = createDemoCanvas('demo-sdf-stroke');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${stripes}
          <figcaption>Cross-line stripes</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${gradient}
          <figcaption>Cross-line gradient</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${sdfStroke}
          <figcaption>SDF stroke</figcaption>
        </figure>
      </div>`);

      const shaderStripes = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          // Cross-line stripes using lineCoord.y
          let stripe = select(0.0, 1.0, lineCoord.y >= 0.0);
          return vec4f(stripe * 0.2, 0.5, 0.9 - stripe * 0.4, 1.0);
        }
      `;

      const shaderGradient = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          let t = lineCoord.y * 0.5 + 0.5;
          let top = vec3f(1.0, 0.4, 0.2);
          let bottom = vec3f(0.2, 0.4, 1.0);
          let color = mix(bottom, top, t);
          return vec4f(color, 1.0);
        }
      `;

      const shaderSDF = /* wgsl */`
        fn linearstep(a: f32, b: f32, x: f32) -> f32 {
          return clamp((x - a) / (b - a), 0.0, 1.0);
        }
        fn getColor(lineCoord: vec2f) -> vec4f {
          let width = 50.0;
          let strokeWidth = 5.0;
          // Use length(lineCoord) for proper SDF on both segments and caps
          let dist = length(lineCoord);
          let sdf = 0.5 * width * dist;
          let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);
          let strokeMask = linearstep(width * 0.5 - strokeWidth - 0.5, width * 0.5 - strokeWidth + 0.5, sdf);
          let fillColor = vec3f(0.4, 0.7, 1.0);
          let strokeColor = vec3f(0.1, 0.3, 0.6);
          let color = mix(fillColor, strokeColor, strokeMask);
          return vec4f(color, aa);
        }
      `;

      const blend = {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      };

      const baseOpts = { pattern: 'shader-demo', join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(stripes, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderStripes });
      await demoRenderer.renderToCanvas(gradient, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderGradient });
      await demoRenderer.renderToCanvas(sdfStroke, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderSDF, blend });
    }
  </script>
  <script id="34" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, '`vertexShaderBody`')}`);
  </script>
  <script id="35" type="module">
    import apiMd from './API.md?raw';
    import { getSectionWithHeading } from './lib/markdown-sections.js';

    display(md`${getSectionWithHeading(apiMd, 'Drawing', 2)}`);
  </script>
  <script id="37" type="text/markdown">
    ---

    ### Export Images

    Download all demo images for documentation.
  </script>
  <script id="38" type="module">
    function downloadURI(uri, filename) {
      const link = document.createElement("a");
      link.target = '_blank';
      link.download = filename;
      link.href = uri;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function downloadAllImages() {
      const canvases = document.querySelectorAll('canvas[id^="demo-"]');
      Array.from(canvases).forEach((canvas, i) => {
        setTimeout(() => {
          const uri = canvas.toDataURL('image/png');
          const filename = canvas.id.replace('demo-', '') + '.png';
          downloadURI(uri, filename);
        }, i * 300);
      });
    }

    const btn = html`<button style="padding: 8px 16px; cursor: pointer;">Download All Demo Images</button>`;
    btn.onclick = downloadAllImages;
    display(btn);
  </script>
</notebook>
