const e="# API Reference\n\n## `createGPULines(device, options)`\n\nCreates a new line renderer instance.\n\n**Parameters:**\n- `device` - WebGPU device\n- `options` - Configuration object (see below)\n\n**Returns:** Line renderer object with `draw()`, `getBindGroupLayout()`, and `destroy()` methods.\n\n## Options\n\n### `join`\n\nControls how line segments are connected at vertices. Options are `'bevel'`, `'miter'`, and `'round'`.\n\n### `cap`\n\nControls how line endpoints are rendered. Options are `'round'`, `'square'`, and `'butt'`.\n\n### `miterLimit`\n\nWhen using `join: 'miter'`, this controls when sharp angles fall back to bevel joins. Lower values create more bevels. Higher values allow longer miter points. Default is `4`.\n\n### `joinResolution` and `capResolution`\n\nControl the number of triangles used for round joins and caps. Higher values create smoother curves. Default is `8`.\n\n### Line Breaks\n\nInsert a point with `w = 0` (or `NaN` for any coordinate) to create a line break. This splits the line into separate segments, each with its own end caps.\n\n## Custom Shaders\n\nThe library supports custom WGSL shaders for advanced rendering effects. Provide shader code via the `fragmentShaderBody` and `vertexShaderBody` options.\n\nThe library parses your `Vertex` struct to identify the position, width, and varying fields automatically. The library reserves `@group(0)` for its internal uniforms; your shader code should use `@group(1)` and higher for your own data.\n\n### `fragmentShaderBody`\n\nThe fragment shader controls how lines are colored. Your code must define a `getColor` function.\n\n```wgsl\nfn getColor(lineCoord: vec2f) -> vec4f {\n  // Return RGBA color (0-1 range)\n  return vec4f(0.2, 0.5, 0.9, 1.0);\n}\n```\n\nThe `lineCoord` parameter provides spatial information about the current fragment (see below).\n\nAny fields in your `Vertex` struct beyond `position` and `width` become varyings, interpolated across the line and passed as additional parameters to `getColor`. For example, if your struct includes `dist: f32`, your function signature becomes `fn getColor(lineCoord: vec2f, dist: f32) -> vec4f`.\n\nIf your shader code references `instanceID`, the library will automatically pass two additional parameters, `instanceID: f32` (segment index, negative for end caps) and `triStripCoord: vec2f` (triangle strip vertex coordinates for wireframe visualization). These are useful for debug views showing the internal triangle strip structure.\n\n### `lineCoord` Values\n\n| Component | Segments/Joins | Caps | Description |\n|-----------|----------------|------|-------------|\n| `lineCoord.x` | 0 | sin(θ) × sign | Always 0 for segments. Varies around the semicircle for caps. |\n| `lineCoord.y` | -1 to 1 | cos(θ) × sign | Position across the line. 0 at center, ±1 at edges. |\n\nThe `lineCoord` values are designed for SDF (signed distance field) rendering. `length(lineCoord)` gives radial distance from line center (0 at center, 1 at edge). For segments, `length(lineCoord) = abs(lineCoord.y)` since x=0. For caps, `length(lineCoord) = 1` on the outer edge (unit circle).\n\nNote that `lineCoord.x` does NOT provide distance along the line. To implement dashes, add a cumulative distance field to your `Vertex` struct. It will be interpolated and passed to `getColor` as an extra parameter. See the interactive demo's \"Stripes\" option for an example.\n\n### Example Shaders\n\nSolid color with edge darkening.\n```wgsl\nfn getColor(lineCoord: vec2f) -> vec4f {\n  let edge = 1.0 - 0.3 * abs(lineCoord.y);\n  return vec4f(0.2 * edge, 0.5 * edge, 0.9 * edge, 1.0);\n}\n```\n\nCross-line stripes using `lineCoord.y`.\n```wgsl\nfn getColor(lineCoord: vec2f) -> vec4f {\n  let stripe = step(0.0, lineCoord.y);\n  return vec4f(stripe * 0.2, 0.5, 0.9 - stripe * 0.4, 1.0);\n}\n```\n\nSDF stroke with anti-aliasing.\n```wgsl\nfn linearstep(a: f32, b: f32, x: f32) -> f32 {\n  return clamp((x - a) / (b - a), 0.0, 1.0);\n}\nfn getColor(lineCoord: vec2f) -> vec4f {\n  let width = 20.0;\n  let strokeWidth = 4.0;\n  let sdf = 0.5 * width * length(lineCoord);\n  let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);\n  let strokeMask = linearstep(\n    width * 0.5 - strokeWidth - 0.5,\n    width * 0.5 - strokeWidth + 0.5, sdf);\n  let fillColor = vec3f(0.4, 0.7, 1.0);\n  let strokeColor = vec3f(0.1, 0.3, 0.6);\n  let color = mix(fillColor, strokeColor, strokeMask);\n  return vec4f(color, aa);\n}\n```\n\nWhen using transparency or `discard`, enable alpha blending.\n```javascript\ncreateGPULines(device, {\n  colorTargets: {\n    format: canvasFormat,\n    blend: {\n      color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },\n      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }\n    }\n  }\n});\n```\n\n### `vertexShaderBody`\n\nThe vertex shader body defines how line positions and per-vertex data are computed. You provide bind group declarations (group 1+) for your data, a struct defining the vertex output, and a vertex function that returns the struct given a point index.\n\nThe `position` field is a `vec4f` in clip space: `x` and `y` range from -1 to 1, `z` is depth, and `w` must be non-zero for valid points (0 or NaN signals a line break).\n\n```wgsl\n@group(1) @binding(0) var<storage, read> positions: array<vec4f>;\n@group(1) @binding(1) var<uniform> viewMatrix: mat4x4f;\n\nstruct Vertex {\n  position: vec4f,  // Clip-space position (w must be non-zero; w=0 or NaN for line breaks)\n  width: f32,       // Line width in pixels\n  // Additional fields become varyings passed to fragment shader\n}\n\nfn getVertex(index: u32) -> Vertex {\n  let p = positions[index];\n  let projected = viewMatrix * vec4f(p.xyz, 1.0);\n  return Vertex(vec4f(projected.xyz, p.w * projected.w), 20.0);\n}\n```\n\nYour `getVertex` function can read from any source (buffers, textures, procedural) and transform to clip space however you like.\n\nOptions for customization include `vertexFunction` (name of your vertex function, default `'getVertex'`), `positionField` (name of position field in struct, default `'position'`), and `widthField` (name of width field in struct, default `'width'`).\n\nAvailable library uniforms are `uniforms.resolution` (canvas resolution in pixels) and `uniforms.pointCount` (number of points).\n\n## Drawing\n\n### `gpuLines.draw(pass, props, bindGroups)`\n\nDraws lines in a render pass. The `props` object includes `vertexCount` (number of points in the line) and `resolution` (canvas resolution as `[width, height]`). The `bindGroups` parameter is an array of user bind groups for groups 1, 2, etc.\n\n### `gpuLines.getBindGroupLayout(index)`\n\nReturns the bind group layout for the specified group index. Use this to create bind groups for your data.\n\n```javascript\nconst dataBindGroup = device.createBindGroup({\n  layout: gpuLines.getBindGroupLayout(1),\n  entries: [\n    { binding: 0, resource: { buffer: positionBuffer } },\n    { binding: 1, resource: { buffer: viewMatrixBuffer } }\n  ]\n});\n\nconst pass = encoder.beginRenderPass({ ... });\ngpuLines.draw(pass, {\n  vertexCount: points.length,\n  resolution: [canvas.width, canvas.height]\n}, [dataBindGroup]);\npass.end();\n```\n\n";export{e as default};
