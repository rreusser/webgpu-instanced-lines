import{createGPULines as Q}from"./webgpu-lines-DopDqc-X.js";function K(n,M,y,m){const B=new Map;let w=null,b=null,F=0,E=0;function V(e,t){if(w&&F===e&&E===t)return;w&&w.destroy(),b&&b.destroy(),F=e,E=t,w=n.createTexture({size:[e,t],format:m,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=Math.ceil(e*4/256)*256;b=n.createBuffer({size:r*t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})}const S=[];let A=!1;async function _(){if(!(A||S.length===0)){for(A=!0;S.length>0;){const{targetCanvas:e,options:t,resolve:r,reject:a}=S.shift();try{const o=window.devicePixelRatio||1,l=t.width||parseInt(e.style.width)||e.width,c=t.height||parseInt(e.style.height)||e.height,s=Math.floor(l*o),p=Math.floor(c*o);e.width=s,e.height=p,e.style.width=`${l}px`,e.style.height=`${c}px`,V(s,p),await H(w,{...t,width:l,height:c});const z=Math.ceil(s*4/256)*256,x=n.createCommandEncoder();x.copyTextureToBuffer({texture:w},{buffer:b,bytesPerRow:z},[s,p]),n.queue.submit([x.finish()]),await b.mapAsync(GPUMapMode.READ);const u=new Uint8Array(b.getMappedRange()),d=new ImageData(s,p),P=m==="bgra8unorm";for(let g=0;g<p;g++)for(let h=0;h<s;h++){const i=g*z+h*4,f=(g*s+h)*4;P?(d.data[f+0]=u[i+2],d.data[f+1]=u[i+1],d.data[f+2]=u[i+0],d.data[f+3]=u[i+3]):(d.data[f+0]=u[i+0],d.data[f+1]=u[i+1],d.data[f+2]=u[i+2],d.data[f+3]=u[i+3])}b.unmap(),e.getContext("2d").putImageData(d,0,0),r()}catch(o){a(o)}}A=!1}}function j(e){const t=JSON.stringify(e);if(B.has(t))return B.get(t);const{join:r="miter",joinResolution:a=8,miterLimit:o=4,cap:l="round",capResolution:c=8,sdfStrokeWidth:s=0,lineWidth:p=20,fragmentShaderBody:z=null,blend:x=null}=e,u=s>0,d=`
      @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
      @group(1) @binding(1) var<uniform> viewMatrix: mat4x4f;

      struct Vertex {
        position: vec4f,
        width: f32,
      }

      fn getVertex(index: u32) -> Vertex {
        let p = positions[index];
        let projected = viewMatrix * vec4f(p.xyz, 1.0);
        return Vertex(vec4f(projected.xyz, p.w * projected.w), ${p.toFixed(1)});
      }
    `,P=`
      fn getColor(lineCoord: vec2f) -> vec4f {
        let edge = 1.0 - 0.3 * abs(lineCoord.y);
        return vec4f(0.2 * edge, 0.5 * edge, 0.9 * edge, 1.0);
      }
    `,C=`
      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }
      fn getColor(lineCoord: vec2f) -> vec4f {
        let width = ${p.toFixed(1)};
        let strokeWidth = ${s.toFixed(1)};
        let sdf = 0.5 * width * length(lineCoord.xy);
        let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);
        let strokeMask = linearstep(width * 0.5 - strokeWidth - 0.5, width * 0.5 - strokeWidth + 0.5, sdf);
        let fillColor = vec3f(0.4, 0.7, 1.0);
        let strokeColor = vec3f(0.1, 0.3, 0.6);
        let color = mix(fillColor, strokeColor, strokeMask);
        return vec4f(color, aa);
      }
    `;let g;z?g=z:u?g=C:g=P;let h;x!==null?h=x:u?h={color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}:h=null;const i=Q(n,{format:m,join:r,joinResolution:a,miterLimit:o,cap:l,capResolution:c,vertexShaderBody:d,fragmentShaderBody:g,blend:h});return B.set(t,i),i}function D(e,t={}){const{lineBreak:r=!1}=t;let a=[];switch(e){case"zigzag":for(let o=0;o<6;o++){const c=-.6+o/5*1.2,s=o%2===0?.2:-.2;a.push({x:c,y:s,z:0,w:1})}break;case"spiral":for(let o=0;o<80;o++){const l=o/79,c=l*Math.PI*6,s=.1+l*.6;a.push({x:s*Math.cos(c),y:s*Math.sin(c),z:0,w:1})}break;case"wave":for(let o=0;o<100;o++){const l=o/99,c=-.8+l*1.6,s=.3*Math.sin(l*Math.PI*4)+.2*Math.cos(l*Math.PI*7);a.push({x:c,y:s,z:0,w:1})}break;case"join-demo":a=[{x:-.7,y:.3,z:0,w:1},{x:-.25,y:-.3,z:0,w:1},{x:.25,y:.3,z:0,w:1},{x:.7,y:-.3,z:0,w:1}];break;case"cap-demo":a=[{x:-.55,y:0,z:0,w:1},{x:.55,y:0,z:0,w:1}];break;case"miter-demo":a=[{x:-.6,y:-.1,z:0,w:1},{x:0,y:.35,z:0,w:1},{x:.6,y:-.1,z:0,w:1}];break;case"resolution-demo":a=[{x:-.5,y:-.2,z:0,w:1},{x:0,y:-.2,z:0,w:1},{x:0,y:.4,z:0,w:1}];break;case"break-demo":a=[{x:-.65,y:.15,z:0,w:1},{x:-.3,y:-.2,z:0,w:1},{x:0,y:.15,z:0,w:1},{x:.3,y:-.2,z:0,w:1},{x:.65,y:.15,z:0,w:1}];break;case"shader-demo":a=[{x:-.6,y:.1,z:0,w:1},{x:-.2,y:-.25,z:0,w:1},{x:.2,y:.25,z:0,w:1},{x:.6,y:-.1,z:0,w:1}];break;default:a=D("zigzag",t)}if(r){const o=Math.floor(a.length/2);a.splice(o,0,{x:0,y:0,z:0,w:0})}return a}function q(e){const t=new Float32Array(e.length*4);for(let r=0;r<e.length;r++)t[r*4+0]=e[r].x,t[r*4+1]=e[r].y,t[r*4+2]=e[r].z,t[r*4+3]=e[r].w;return t}async function Y(e={}){const{pattern:t="zigzag",lineWidth:r=20,join:a="miter",joinResolution:o=8,miterLimit:l=4,cap:c="round",capResolution:s=8,sdfStrokeWidth:p=0,lineBreak:z=!1,width:x=320,height:u=200,points:d=null,viewMatrix:P=null,clearColor:C={r:.95,g:.95,b:.95,a:1},fragmentShaderBody:g=null,blend:h=null}=e,i=window.devicePixelRatio||1;(y.width!==x*i||y.height!==u*i)&&(y.width=x*i,y.height=u*i);const f=j({join:a,joinResolution:o,miterLimit:l,cap:c,capResolution:s,sdfStrokeWidth:p,lineWidth:r,fragmentShaderBody:g,blend:h}),T=d||D(t,{lineBreak:z}),v=q(T),U=n.createBuffer({label:"demo-positions",size:v.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(U,0,v);const O=P||new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),k=n.createBuffer({label:"demo-view-matrix",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(k,0,O);const G=n.createBindGroup({layout:f.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:U}},{binding:1,resource:{buffer:k}}]}),W=n.createCommandEncoder(),R=W.beginRenderPass({colorAttachments:[{view:M.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:C}]});return f.draw(R,{vertexCount:T.length,width:r,resolution:[y.width,y.height]},[G]),R.end(),n.queue.submit([W.finish()]),U.destroy(),k.destroy(),await n.queue.onSubmittedWorkDone(),{width:x*i,height:u*i}}async function H(e,t={}){const{pattern:r="zigzag",lineWidth:a=20,join:o="miter",joinResolution:l=8,miterLimit:c=4,cap:s="round",capResolution:p=8,sdfStrokeWidth:z=0,lineBreak:x=!1,width:u=320,height:d=200,points:P=null,viewMatrix:C=null,clearColor:g={r:.95,g:.95,b:.95,a:1},fragmentShaderBody:h=null,blend:i=null}=t,f=window.devicePixelRatio||1,T=Math.floor(u*f),v=Math.floor(d*f),U=j({join:o,joinResolution:l,miterLimit:c,cap:s,capResolution:p,sdfStrokeWidth:z,lineWidth:a,fragmentShaderBody:h,blend:i}),O=P||D(r,{lineBreak:x}),k=q(O),G=n.createBuffer({label:"demo-positions",size:k.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(G,0,k);const W=C||new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),R=n.createBuffer({label:"demo-view-matrix",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(R,0,W);const J=n.createBindGroup({layout:U.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:G}},{binding:1,resource:{buffer:R}}]}),L=n.createCommandEncoder(),I=L.beginRenderPass({colorAttachments:[{view:e.createView(),loadOp:"clear",storeOp:"store",clearValue:g}]});U.draw(I,{vertexCount:O.length,width:a,resolution:[T,v]},[J]),I.end(),n.queue.submit([L.finish()]),G.destroy(),R.destroy(),await n.queue.onSubmittedWorkDone()}function N(e,t={}){return new Promise((r,a)=>{S.push({targetCanvas:e,options:t,resolve:r,reject:a}),_()})}function $(){for(const e of B.values())e.destroy();B.clear(),w&&w.destroy(),b&&b.destroy()}return{render:Y,renderToCanvas:N,generateDemoPoints:D,destroy:$}}async function Z(){if(!navigator.gpu)throw new Error("WebGPU not supported");const n=await navigator.gpu.requestAdapter();if(!n)throw new Error("Failed to get WebGPU adapter");const M=await n.requestDevice(),y=navigator.gpu.getPreferredCanvasFormat(),m=document.createElement("canvas");m.width=640,m.height=400;const B=m.getContext("webgpu");B.configure({device:M,format:y,alphaMode:"premultiplied"});const w=K(M,B,m,y);return{...w,device:M,canvas:m,destroy(){w.destroy(),M.destroy()}}}export{K as createDemoRenderer,Z as initDemoRenderer};
