<!doctype html>
<notebook theme="air">
  <title>WebGPU Instanced Lines</title>
  <script id="1" type="module">
    const link = html`<a href="https://github.com/rreusser/webgpu-instanced-lines" target="_blank" style="
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #24292e;
      color: white;
      border-radius: 6px;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      float: right;
      margin: 0 0 10px 10px;
    ">
      <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
      View on GitHub
    </a>`;
    display(link);
  </script>
  <script id="1b" type="text/markdown">
    # WebGPU Instanced Lines

    High-performance, flexible GPU-accelerated line rendering for WebGPU. This is a direct port of [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines) to WebGPU. The focus is on speed and customizability rather than sophisticated stroke expansion algorithms. Drag handles to edit vertices, drag the background to pan, and scroll to zoom. Enable **Debug view** to see the underlying triangle strip structure.
  </script>
  <script id="2" type="module">
    // Initialize WebGPU for interactive demo
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="module">
    // Initialize offscreen demo renderer for static examples
    import { initDemoRenderer } from './demo-renderer.js';

    const demoRenderer = await initDemoRenderer();
    invalidation.then(() => demoRenderer.destroy());
  </script>
  <script id="4" type="text/markdown">
  </script>
  <script id="5" type="module">
    import { createElementStack } from './element-stack.js'
    import { createZoomableAxes } from './zoomable-axes.js'
    import { expandable } from './expandable.js'

    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    const renderState = { dirty: true };

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => {
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption>Drag handles to edit vertices. Drag background to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: canvasWidth,
      height: canvasHeight,
      controls: '.lines-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          d3.scaleLinear().domain([-1, 1]).range([0, w]),
          d3.scaleLinear().domain([-1, 1]).range([h, 0])
        );
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    }));
  </script>
  <script id="6" type="module">
    const lineWidthInput = Inputs.range([1, 100], { label: 'Line width', value: 50, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const capTypeInput = Inputs.select(['round', 'square', 'butt'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const sdfStrokeWidthInput = Inputs.range([0, 50], { label: 'SDF stroke width', value: 10, step: 0.5 });
    const sdfStrokeWidth = view(sdfStrokeWidthInput);

    const alphaInput = Inputs.range([0, 1], { label: 'Alpha', value: 1, step: 0.01 });
    const alpha = view(alphaInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    const stripesInput = Inputs.toggle({ label: 'Stripes', value: false });
    const stripes = view(stripesInput);

    const varyingWidthInput = Inputs.toggle({ label: 'Varying width', value: false });
    const varyingWidth = view(varyingWidthInput);

    const debugViewInput = Inputs.toggle({ label: 'Debug view', value: 'Debug view' });
    const debugView = view(debugViewInput);
  </script>
  <script id="7" type="module">
    const miterLimitInput = Inputs.range([1, 10], {
      label: 'Miter limit',
      value: 4,
      step: 0.1,
      disabled: joinType !== 'miter'
    });
    const miterLimit = view(miterLimitInput);
  </script>
  <script id="8" type="module">
    const joinResolutionInput = Inputs.range([2, 16], {
      label: 'Round join resolution',
      value: 8,
      step: 1,
      disabled: joinType !== 'round'
    });
    const joinResolution = view(joinResolutionInput);
  </script>
  <script id="9" type="module">
    const capResolutionInput = Inputs.range([2, 16], {
      label: 'Round cap resolution',
      value: 8,
      step: 1,
      disabled: capType !== 'round'
    });
    const capResolution = view(capResolutionInput);
  </script>
  <script id="10" type="module">
    display(html`<div class="lines-controls">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfStrokeWidthInput}
      ${alphaInput}
      ${lineBreakInput}
      ${stripesInput}
      ${varyingWidthInput}
      ${debugViewInput}
    </div>`);
  </script>
  <script id="11" type="module">
    import { createGPULines } from '../webgpu-instanced-lines.js';

    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push({ x: r * Math.cos(angle), y: r * Math.sin(angle), z: 0, w: 1 });
        }
      } else {
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      }

      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, { x: 0, y: 0, z: 0, w: 0 });
      }

      return basePoints;
    }

    const points = generatePattern(pattern, lineBreak);
    const numPoints = points.length;

    function pointsToFloat32Array(pts) {
      const arr = new Float32Array(pts.length * 4);
      for (let i = 0; i < pts.length; i++) {
        arr[i * 4 + 0] = pts[i].x;
        arr[i * 4 + 1] = pts[i].y;
        arr[i * 4 + 2] = pts[i].z;
        arr[i * 4 + 3] = pts[i].w;
      }
      return arr;
    }

    // Compute cumulative distance along the line
    function computeDistances(pts) {
      const distances = new Float32Array(pts.length);
      let cumDist = 0;
      for (let i = 0; i < pts.length; i++) {
        if (pts[i].w === 0) {
          // Line break - reset distance
          cumDist = 0;
        } else if (i > 0 && pts[i - 1].w !== 0) {
          const dx = pts[i].x - pts[i - 1].x;
          const dy = pts[i].y - pts[i - 1].y;
          cumDist += Math.sqrt(dx * dx + dy * dy);
        }
        distances[i] = cumDist;
      }
      return distances;
    }

    const positions = pointsToFloat32Array(points);
    const distances = computeDistances(points);
    const totalDistance = Math.max(...distances);

    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    const distanceBuffer = device.createBuffer({
      label: 'line-distances',
      size: distances.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(distanceBuffer, 0, distances);

    const totalDistanceBuffer = device.createBuffer({
      label: 'total-distance',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([totalDistance]));

    function updateBuffers() {
      const newPositions = pointsToFloat32Array(points);
      const newDistances = computeDistances(points);
      const newTotalDistance = Math.max(...newDistances);
      device.queue.writeBuffer(positionBuffer, 0, newPositions);
      device.queue.writeBuffer(distanceBuffer, 0, newDistances);
      device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([newTotalDistance]));
      renderState.dirty = true;
    }

    invalidation.then(() => {
      positionBuffer.destroy();
      distanceBuffer.destroy();
      totalDistanceBuffer.destroy();
    });
  </script>
  <script id="12" type="module">
    const svg = d3.select(stack.elements.svg);

    const editablePoints = points.map((p, i) => ({ point: p, index: i }))
                                 .filter(d => d.point.w !== 0);

    // Use groups with invisible hit area + visible circle
    const handleGroups = svg.selectAll('g.vertex-handle')
      .data(editablePoints, d => d.index)
      .join('g')
      .attr('class', 'vertex-handle')
      .attr('cursor', 'move')
      .call(d3.drag()
        .on('start', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#0066cc').attr('stroke-width', 2);
        })
        .on('drag', function(event, d) {
          d.point.x = axes.xScale.invert(event.x);
          d.point.y = axes.yScale.invert(event.y);
          d3.select(this).attr('transform', `translate(${event.x},${event.y})`);
          updateBuffers();
        })
        .on('end', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#333').attr('stroke-width', 1.5);
        })
      );

    // Invisible hit area (larger)
    handleGroups.append('circle')
      .attr('class', 'hit-area')
      .attr('r', 20)
      .attr('fill', 'transparent');

    // Visible circle (smaller)
    handleGroups.append('circle')
      .attr('class', 'visible')
      .attr('r', 5)
      .attr('fill', 'white')
      .attr('stroke', '#333')
      .attr('stroke-width', 1.5)
      .attr('pointer-events', 'none');

    function updateHandlePositions() {
      handleGroups.attr('transform', d =>
        `translate(${axes.xScale(d.point.x)},${axes.yScale(d.point.y)})`);
    }

    updateHandlePositions();
    stack.addEventListener('update', updateHandlePositions);
  </script>
  <script id="13" type="module">
    // Only depend on shader-affecting parameters (join/cap type, shader options)
    // Resolution and miterLimit are now runtime parameters passed to draw()
    joinType; capType; sdfStrokeWidth; alpha; stripes; varyingWidth; debugView;

    const useSdfMode = sdfStrokeWidth > 0;
    const useBlend = useSdfMode || alpha < 1 || debugView;

    // Vertex shader body with position buffer, distance buffer, and view matrix
    const vertexShaderBody = /* wgsl */`
      @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
      @group(1) @binding(1) var<storage, read> distances: array<f32>;
      @group(1) @binding(2) var<uniform> viewMatrix: mat4x4f;
      @group(1) @binding(3) var<uniform> totalDistance: f32;
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;
      @group(1) @binding(5) var<uniform> lineWidthUniform: f32;

      struct Vertex {
        position: vec4f,
        width: f32,
        dist: f32,      // cumulative distance along line
        lineWidth: f32, // interpolated width for fragment shader
      }

      fn getVertex(index: u32) -> Vertex {
        let p = positions[index];
        let d = distances[index];
        let projected = viewMatrix * vec4f(p.xyz, 1.0);
        // Reference totalDistance to ensure it's included in bind group layout
        let normalizedDist = d / totalDistance;
        let w = ${varyingWidth ? 'lineWidthUniform * (0.5 + 1.5 * normalizedDist)' : 'lineWidthUniform'};
        return Vertex(vec4f(projected.xyz, p.w * projected.w), w, d, w);
      }
    `;

    // SDF distance function: round uses length, square uses max(abs)
    const sdfDistFn = capType === 'square'
      ? 'max(abs(lineCoord.x), abs(lineCoord.y))'
      : 'length(lineCoord.xy)';

    // Unified fragment shader handling all modes
    const fragmentShaderBody = /* wgsl */`
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;

      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }

      // Unit grid lines for wireframe
      fn grid(parameter: vec3f, width: f32, feather: f32) -> f32 {
        let w1 = width - feather * 0.5;
        let d = fwidth(parameter);
        let looped = 0.5 - abs(parameter % 1.0 - 0.5);
        let a3 = smoothstep(d * w1, d * (w1 + feather), looped);
        return min(min(a3.x, a3.y), a3.z);
      }

      fn getColor(lineCoord: vec2f, dist: f32, lineWidth: f32, instanceID: f32, triStripCoord: vec2f) -> vec4f {
        let strokeWidth = ${sdfStrokeWidth.toFixed(1)} * debug.dpr;
        let baseAlpha = ${alpha.toFixed(2)};

        // Compute SDF values
        let sdf = 0.5 * lineWidth * ${sdfDistFn};
        let aa = select(baseAlpha, linearstep(lineWidth * 0.5, lineWidth * 0.5 - 1.0, sdf) * baseAlpha, strokeWidth > 0.0);
        let strokeMask = select(0.0, linearstep(lineWidth * 0.5 - strokeWidth - 0.5, lineWidth * 0.5 - strokeWidth + 0.5, sdf), strokeWidth > 0.0);

        // Layer 1: Base fill color (debug instance color or normal color)
        var baseColor: vec3f;
        if (debug.enabled == 1u) {
          let iInstanceID = floor(instanceID + 0.5);
          if (iInstanceID < 0.0) {
            baseColor = vec3f(0.8, 0.1, 0.4);  // Red/pink for caps
          } else {
            baseColor = select(vec3f(0.8, 0.1, 0.4), vec3f(0.1, 0.7, 1.0), i32(iInstanceID) % 2 == 0);
          }
        } else {
          baseColor = vec3f(0.1, 0.7, 1.0);
        }

        // Layer 2: Apply stripes on top of base color
        let stripeFreq = 20.0;
        let stripe = step(0.5, fract(dist * stripeFreq));
        let stripeColor = baseColor * 0.4;  // Darker version of base
        var color = ${stripes ? 'mix(baseColor, stripeColor, stripe)' : 'baseColor'};

        // Layer 3: Apply stroke (50% black in debug mode, dark blue in normal mode)
        color = mix(color, vec3f(0.0), strokeMask * 0.7);

        // Layer 4: Wireframe gridlines (debug only)
        if (debug.enabled == 1u) {
          let wire = grid(vec3f(triStripCoord, triStripCoord.x + triStripCoord.y), 0.5 * debug.dpr, 1.0);
          color = mix(vec3f(1.0), color, wire);
        }

        return vec4f(color, aa);
      }
    `;

    // Use max resolutions at init time to allow runtime adjustment up to these values
    // Runtime values (miterLimit, joinResolution, capResolution) are passed to draw()
    const gpuLines = createGPULines(device, {
      format: canvasFormat,
      join: joinType,
      maxJoinResolution: 16,  // Allow up to 16 at runtime
      maxCapResolution: 16,   // Allow up to 16 at runtime
      cap: capType,
      vertexShaderBody,
      fragmentShaderBody,
      blend: useBlend ? {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      } : null
    });

    // Create view matrix buffer
    const viewMatrixBuffer = device.createBuffer({
      label: 'view-matrix',
      size: 64, // mat4x4f
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create debug uniform buffer (8 bytes: u32 enabled + f32 dpr)
    const debugBuffer = device.createBuffer({
      label: 'debug-uniform',
      size: 8,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create line width uniform buffer
    const lineWidthBuffer = device.createBuffer({
      label: 'line-width-uniform',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create bind group for user data (group 1)
    const dataBindGroup = device.createBindGroup({
      layout: gpuLines.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: { buffer: positionBuffer } },
        { binding: 1, resource: { buffer: distanceBuffer } },
        { binding: 2, resource: { buffer: viewMatrixBuffer } },
        { binding: 3, resource: { buffer: totalDistanceBuffer } },
        { binding: 4, resource: { buffer: debugBuffer } },
        { binding: 5, resource: { buffer: lineWidthBuffer } }
      ]
    });

    invalidation.then(() => {
      gpuLines.destroy();
      viewMatrixBuffer.destroy();
      lineWidthBuffer.destroy();
      debugBuffer.destroy();
    });
  </script>
  <script id="14" type="module">
    import { createFrameLoop } from './frame-loop.js';

    // Depend on runtime parameters that don't require pipeline recreation
    lineWidth; debugView; miterLimit; joinResolution; capResolution; renderState.dirty = true;

    const loop = createFrameLoop(() => {
      if (renderState.dirty) {
        // Update view matrix buffer
        device.queue.writeBuffer(viewMatrixBuffer, 0, axes.view);

        // Update debug uniform (enabled: u32, dpr: f32)
        const debugData = new ArrayBuffer(8);
        new Uint32Array(debugData, 0, 1)[0] = debugView ? 1 : 0;
        new Float32Array(debugData, 4, 1)[0] = dpr;
        device.queue.writeBuffer(debugBuffer, 0, debugData);

        // Update line width uniform
        device.queue.writeBuffer(lineWidthBuffer, 0, new Float32Array([lineWidth * dpr]));

        const encoder = device.createCommandEncoder();

        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1 }
          }]
        });

        // Pass runtime parameters (miterLimit, joinResolution, capResolution)
        // These update uniforms without recreating the pipeline
        gpuLines.draw(pass, {
          vertexCount: numPoints,
          resolution: [canvas.width, canvas.height],
          miterLimit: miterLimit,
          joinResolution: joinResolution,
          capResolution: capResolution
        }, [dataBindGroup]);

        pass.end();
        device.queue.submit([encoder.finish()]);
        renderState.dirty = false;
      }
    });

    invalidation.then(() => loop.cancel());
  </script>
  <script id="14b" type="text/markdown">
    ---

    ## Installation

    ```bash
    npm install webgpu-instanced-lines
    ```

    ## Usage

    ```javascript
    import { createGPULines } from 'webgpu-instanced-lines';

    const gpuLines = createGPULines(device, {
      format: canvasFormat,
      join: 'round',
      cap: 'round',
      vertexShaderBody: /* wgsl */`
        @group(1) @binding(0) var<storage, read> positions: array<vec4f>;

        struct Vertex {
          position: vec4f,
          width: f32,
        }

        fn getVertex(index: u32) -> Vertex {
          return Vertex(positions[index], 10.0);
        }
      `,
      fragmentShaderBody: /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          return vec4f(0.2, 0.5, 0.9, 1.0);
        }
      `
    });

    // In render loop:
    gpuLines.draw(pass, {
      vertexCount: numPoints,
      width: 20,
      resolution: [canvas.width, canvas.height]
    }, [dataBindGroup]);
    ```

    For background on GPU line rendering, see Matt DesLauriers' [Drawing Lines is Hard](https://mattdesl.svbtle.com/drawing-lines-is-hard) and Rye Terrell's [Instanced Line Rendering](https://wwwtyro.net/2019/11/18/instanced-lines.html).
  </script>
  <script id="15" type="text/markdown">

    ## How It Works

    ### Background

    The renderer uses **instanced rendering** with triangle strips. For a line with N points, it draws N-1 instances, where each instance renders one line segment plus half of the join geometry on each end. End caps are simply joins stretched around to form a cap.

    The geometry is carefully generated to optimize for high-performance rendering without the full rigor of stroke expansion algorithms, which handle self-intersection more carefully. The `lineCoord` varying is constructed so that `length(lineCoord)` gives consistent radial distance from the line center across both segments and caps, permitting uniform stroke widths.

    ### Features
    - Instanced rendering with triangle strips
    - Screen-projected lines using a custom vertex function that can read geometry from buffers, textures, or procedural computation. The vertex function also defines varying values, line widths, and vertex projection at runtime in the shader.
    - Bevel, miter, and round joins
    - Round, square, and butt end caps
    - Line breaks via `w = 0` sentinel value
    - A `lineCoord` varying that can be used to construct SDF stroke outlines with anti-aliasing

    ### Limitations

    - The library does not handle self-intersecting lines.
    - Rapidly varying line widths render incorrectly.
    - World-space line widths require custom work in the vertex shader function.

    ### Shader Interface

    You provide two pieces of WGSL code.

    **`vertexShaderBody`** defines how to fetch and transform vertex data. You write bind group declarations (`@group(1)` and higher) for your data, a struct containing `position: vec4f`, `width: f32`, and any custom varyings, and a function (default name `getVertex`) that takes a point index and returns your struct.

    **`fragmentShaderBody`** defines how to color the line. You write a `getColor` function that receives `lineCoord: vec2f` plus any varyings from your struct.

    The library parses your struct to identify the position, width, and varying fields automatically. The library reserves `@group(0)` for its internal uniforms. Your shader code should use `@group(1)` and higher for your own data.

    Example:
    ```wgsl
    // In vertexShaderBody:
    @group(1) @binding(0) var<storage, read> positions: array<vec4f>;

    struct Vertex {
      position: vec4f,    // Required
      width: f32,         // Required
      distance: f32,      // Varying - passed to getColor
    }

    fn getVertex(index: u32) -> Vertex {
      let p = positions[index];
      return Vertex(p, 10.0, f32(index));
    }

    // In fragmentShaderBody:
    fn getColor(lineCoord: vec2f, distance: f32) -> vec4f {
      return vec4f(0.2, 0.5, 0.9, 1.0);
    }
    ```

    ### Line Breaks

    To create a line break (splitting one line into multiple segments with separate end caps), have your `getVertex` function return a position with `w = 0` (or `NaN` in any component). The library detects these sentinel values and inserts caps on adjacent segments.

    ### Vertex Window

    Internally, each instance calls `getVertex` for a 4-point window of adjacent vertices. Points **A** (previous) and **D** (next) provide direction for computing join angles. Points **B** (start) and **C** (end) define the segment being drawn.

    Within each instance, a vertex index (0 to ~30, depending on join/cap resolution) expands into the triangle strip vertices. The vertex shader uses this index to compute screen-space offsets perpendicular to the line direction, forming the segment body, joins, and caps.

  </script>
  <script id="16" type="text/markdown">
    ---

    ## API Reference

    ### `createGPULines(device, options)`

    Creates a new line renderer instance.

    **Parameters:**
    - `device` - WebGPU device
    - `options` - Configuration object (see below)

    **Returns:** Line renderer object with `draw()`, `getBindGroupLayout()`, and `destroy()` methods.
  </script>
  <script id="17" type="text/markdown">
    ### Options
  </script>
  <script id="18" type="text/markdown">
    #### `join`

    Controls how line segments are connected at vertices. Options are `'bevel'`, `'miter'`, and `'round'`.
  </script>
  <script id="19" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const joinBevel = createDemoCanvas('demo-join-bevel');
      const joinMiter = createDemoCanvas('demo-join-miter');
      const joinRound = createDemoCanvas('demo-join-round');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${joinBevel}
          <figcaption><code>join: 'bevel'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${joinMiter}
          <figcaption><code>join: 'miter'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${joinRound}
          <figcaption><code>join: 'round'</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'join-demo', lineWidth: 50, cap: 'round', miterLimit: 10, width: 200, height: 120 };
      await demoRenderer.renderToCanvas(joinBevel, { ...baseOpts, join: 'bevel' });
      await demoRenderer.renderToCanvas(joinMiter, { ...baseOpts, join: 'miter' });
      await demoRenderer.renderToCanvas(joinRound, { ...baseOpts, join: 'round' });
    }
  </script>
  <script id="20" type="text/markdown">
    #### `cap`

    Controls how line endpoints are rendered. Options are `'round'`, `'square'`, and `'butt'`.
  </script>
  <script id="21" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const capRound = createDemoCanvas('demo-cap-round');
      const capSquare = createDemoCanvas('demo-cap-square');
      const capButt = createDemoCanvas('demo-cap-butt');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${capRound}
          <figcaption><code>cap: 'round'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${capSquare}
          <figcaption><code>cap: 'square'</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${capButt}
          <figcaption><code>cap: 'butt'</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'cap-demo', lineWidth: 50, width: 200, height: 120 };
      await demoRenderer.renderToCanvas(capRound, { ...baseOpts, cap: 'round' });
      await demoRenderer.renderToCanvas(capSquare, { ...baseOpts, cap: 'square' });
      await demoRenderer.renderToCanvas(capButt, { ...baseOpts, cap: 'butt' });
    }
  </script>
  <script id="22" type="text/markdown">
    #### `miterLimit`

    When using `join: 'miter'`, this controls when sharp angles fall back to bevel joins. Lower values create more bevels. Higher values allow longer miter points. Default is `4`.
  </script>
  <script id="23" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const miter1 = createDemoCanvas('demo-miter-1');
      const miter4 = createDemoCanvas('demo-miter-4');
      const miter10 = createDemoCanvas('demo-miter-10');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${miter1}
          <figcaption><code>miterLimit: 1</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${miter4}
          <figcaption><code>miterLimit: 4</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${miter10}
          <figcaption><code>miterLimit: 10</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'miter-demo', lineWidth: 50, join: 'miter', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(miter1, { ...baseOpts, miterLimit: 1 });
      await demoRenderer.renderToCanvas(miter4, { ...baseOpts, miterLimit: 4 });
      await demoRenderer.renderToCanvas(miter10, { ...baseOpts, miterLimit: 10 });
    }
  </script>
  <script id="24" type="text/markdown">
    #### `joinResolution` and `capResolution`

    Control the number of triangles used for round joins and caps. Higher values create smoother curves. Default is `8`.
  </script>
  <script id="25" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const res2 = createDemoCanvas('demo-res-2');
      const res4 = createDemoCanvas('demo-res-4');
      const res16 = createDemoCanvas('demo-res-16');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${res2}
          <figcaption><code>joinResolution: 2</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${res4}
          <figcaption><code>joinResolution: 4</code></figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${res16}
          <figcaption><code>joinResolution: 16</code></figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'resolution-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(res2, { ...baseOpts, joinResolution: 2 });
      await demoRenderer.renderToCanvas(res4, { ...baseOpts, joinResolution: 4 });
      await demoRenderer.renderToCanvas(res16, { ...baseOpts, joinResolution: 16 });
    }
  </script>
  <script id="26" type="text/markdown">
    #### Line Breaks

    Insert a point with `w = 0` (or `NaN` for any coordinate) to create a line break. This splits the line into separate segments, each with its own end caps.
  </script>
  <script id="27" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const continuous = createDemoCanvas('demo-continuous');
      const withBreak = createDemoCanvas('demo-with-break');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${continuous}
          <figcaption>Continuous line</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${withBreak}
          <figcaption>With line break (<code>w: 0</code>)</figcaption>
        </figure>
      </div>`);

      const baseOpts = { pattern: 'break-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(continuous, { ...baseOpts, lineBreak: false });
      await demoRenderer.renderToCanvas(withBreak, { ...baseOpts, lineBreak: true });
    }
  </script>
  <script id="28" type="text/markdown">
    ---

    ### Custom Shaders

    The library supports custom WGSL shaders for advanced rendering effects. Provide shader code via the `fragmentShaderBody` and `vertexShaderBody` options.
  </script>
  <script id="29" type="text/markdown">
    #### `fragmentShaderBody`

    The fragment shader controls how lines are colored. Your code must define a `getColor` function.

    ```wgsl
    fn getColor(lineCoord: vec2f) -> vec4f {
      // Return RGBA color (0-1 range)
      return vec4f(0.2, 0.5, 0.9, 1.0);
    }
    ```

    The `lineCoord` parameter provides spatial information about the current fragment (see below).

    Any fields in your `Vertex` struct beyond `position` and `width` become varyings, interpolated across the line and passed as additional parameters to `getColor`. For example, if your struct includes `dist: f32`, your function signature becomes `fn getColor(lineCoord: vec2f, dist: f32) -> vec4f`.

    If your shader code references `instanceID`, the library will automatically pass two additional parameters, `instanceID: f32` (segment index, negative for end caps) and `triStripCoord: vec2f` (triangle strip vertex coordinates for wireframe visualization). These are useful for debug views showing the internal triangle strip structure.
  </script>
  <script id="30" type="text/markdown">
    #### `lineCoord` Values

    | Component | Segments/Joins | Caps | Description |
    |-----------|----------------|------|-------------|
    | `lineCoord.x` | 0 | sin(θ) × sign | Always 0 for segments. Varies around the semicircle for caps. |
    | `lineCoord.y` | -1 to 1 | cos(θ) × sign | Position across the line. 0 at center, ±1 at edges. |

    The `lineCoord` values are designed for SDF (signed distance field) rendering. `length(lineCoord)` gives radial distance from line center (0 at center, 1 at edge). For segments, `length(lineCoord) = abs(lineCoord.y)` since x=0. For caps, `length(lineCoord) = 1` on the outer edge (unit circle).

    Note that `lineCoord.x` does NOT provide distance along the line. To implement dashes, add a cumulative distance field to your `Vertex` struct. It will be interpolated and passed to `getColor` as an extra parameter. See the interactive demo's "Stripes" option for an example.
  </script>
  <script id="31" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const lcX = createDemoCanvas('demo-lc-x');
      const lcY = createDemoCanvas('demo-lc-y');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; max-width: 200px;">
          ${lcX}
          <figcaption><code>lineCoord.x</code> (0 on segments, varies in caps)</figcaption>
        </figure>
        <figure style="margin: 0; max-width: 200px;">
          ${lcY}
          <figcaption><code>lineCoord.y</code> (across line)</figcaption>
        </figure>
      </div>`);

      const shaderX = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          // lineCoord.x is 0 for segments, varies in caps (sin(theta))
          let t = abs(lineCoord.x);
          // Blue for segments (x=0), orange gradient in caps
          return vec4f(t, 0.4 * (1.0 - t), 1.0 - t, 1.0);
        }
      `;

      const shaderY = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          let t = lineCoord.y * 0.5 + 0.5;
          return vec4f(t, 0.3, 1.0 - t, 1.0);
        }
      `;

      const baseOpts = { pattern: 'cap-demo', lineWidth: 50, join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(lcX, { ...baseOpts, fragmentShaderBody: shaderX });
      await demoRenderer.renderToCanvas(lcY, { ...baseOpts, fragmentShaderBody: shaderY });
    }
  </script>
  <script id="32" type="text/markdown">
    #### Example Shaders

    Solid color with edge darkening.
    ```wgsl
    fn getColor(lineCoord: vec2f) -> vec4f {
      let edge = 1.0 - 0.3 * abs(lineCoord.y);
      return vec4f(0.2 * edge, 0.5 * edge, 0.9 * edge, 1.0);
    }
    ```

    Cross-line stripes using `lineCoord.y`.
    ```wgsl
    fn getColor(lineCoord: vec2f) -> vec4f {
      let stripe = step(0.0, lineCoord.y);
      return vec4f(stripe * 0.2, 0.5, 0.9 - stripe * 0.4, 1.0);
    }
    ```

    SDF stroke with anti-aliasing.
    ```wgsl
    fn linearstep(a: f32, b: f32, x: f32) -> f32 {
      return clamp((x - a) / (b - a), 0.0, 1.0);
    }
    fn getColor(lineCoord: vec2f) -> vec4f {
      let width = 20.0;
      let strokeWidth = 4.0;
      let sdf = 0.5 * width * length(lineCoord);
      let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);
      let strokeMask = linearstep(
        width * 0.5 - strokeWidth - 0.5,
        width * 0.5 - strokeWidth + 0.5, sdf);
      let fillColor = vec3f(0.4, 0.7, 1.0);
      let strokeColor = vec3f(0.1, 0.3, 0.6);
      let color = mix(fillColor, strokeColor, strokeMask);
      return vec4f(color, aa);
    }
    ```

    When using transparency or `discard`, enable alpha blending.
    ```javascript
    createGPULines(device, {
      blend: {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      }
    });
    ```
  </script>
  <script id="33" type="module">
    {
      const createDemoCanvas = (id, w = 200, h = 120) =>
        html`<canvas id="${id}" style="width: ${w}px; height: ${h}px; border: 1px solid #ddd;"></canvas>`;

      const stripes = createDemoCanvas('demo-stripes');
      const gradient = createDemoCanvas('demo-gradient');
      const sdfStroke = createDemoCanvas('demo-sdf-stroke');

      display(html`<div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-start;">
        <figure style="margin: 0; text-align: center;">
          ${stripes}
          <figcaption>Cross-line stripes</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${gradient}
          <figcaption>Cross-line gradient</figcaption>
        </figure>
        <figure style="margin: 0; text-align: center;">
          ${sdfStroke}
          <figcaption>SDF stroke</figcaption>
        </figure>
      </div>`);

      const shaderStripes = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          // Cross-line stripes using lineCoord.y
          let stripe = select(0.0, 1.0, lineCoord.y >= 0.0);
          return vec4f(stripe * 0.2, 0.5, 0.9 - stripe * 0.4, 1.0);
        }
      `;

      const shaderGradient = /* wgsl */`
        fn getColor(lineCoord: vec2f) -> vec4f {
          let t = lineCoord.y * 0.5 + 0.5;
          let top = vec3f(1.0, 0.4, 0.2);
          let bottom = vec3f(0.2, 0.4, 1.0);
          let color = mix(bottom, top, t);
          return vec4f(color, 1.0);
        }
      `;

      const shaderSDF = /* wgsl */`
        fn linearstep(a: f32, b: f32, x: f32) -> f32 {
          return clamp((x - a) / (b - a), 0.0, 1.0);
        }
        fn getColor(lineCoord: vec2f) -> vec4f {
          let width = 50.0;
          let strokeWidth = 5.0;
          // Use length(lineCoord) for proper SDF on both segments and caps
          let dist = length(lineCoord);
          let sdf = 0.5 * width * dist;
          let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);
          let strokeMask = linearstep(width * 0.5 - strokeWidth - 0.5, width * 0.5 - strokeWidth + 0.5, sdf);
          let fillColor = vec3f(0.4, 0.7, 1.0);
          let strokeColor = vec3f(0.1, 0.3, 0.6);
          let color = mix(fillColor, strokeColor, strokeMask);
          return vec4f(color, aa);
        }
      `;

      const blend = {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      };

      const baseOpts = { pattern: 'shader-demo', join: 'round', cap: 'round', width: 200, height: 120 };
      await demoRenderer.renderToCanvas(stripes, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderStripes });
      await demoRenderer.renderToCanvas(gradient, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderGradient });
      await demoRenderer.renderToCanvas(sdfStroke, { ...baseOpts, lineWidth: 50, fragmentShaderBody: shaderSDF, blend });
    }
  </script>
  <script id="34" type="text/markdown">
    #### `vertexShaderBody`

    The vertex shader body defines how line positions and per-vertex data are computed. You provide bind group declarations (group 1+) for your data, a struct defining the vertex output, and a vertex function that returns the struct given a point index.

    ```wgsl
    @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
    @group(1) @binding(1) var<uniform> viewMatrix: mat4x4f;

    struct Vertex {
      position: vec4f,  // Required, clip-space position (w component controls line breaks)
      width: f32,       // Optional, per-vertex line width
      // Additional fields become varyings passed to fragment shader
    }

    fn getVertex(index: u32) -> Vertex {
      let p = positions[index];
      let projected = viewMatrix * vec4f(p.xyz, 1.0);
      return Vertex(vec4f(projected.xyz, p.w * projected.w), 20.0);
    }
    ```

    Options for customization include `vertexFunction` (name of your vertex function, default `'getVertex'`), `positionField` (name of position field in struct, default `'position'`), and `widthField` (name of width field in struct, default `'width'`).

    Available library uniforms are `uniforms.resolution` (canvas resolution in pixels), `uniforms.width` (fallback line width if no per-vertex width), and `uniforms.pointCount` (number of points).
  </script>
  <script id="35" type="text/markdown">
    ### Drawing

    #### `gpuLines.draw(pass, props, bindGroups)`

    Draws lines in a render pass. The `props` object includes `vertexCount` (number of points in the line), `width` (line width in pixels, fallback if no per-vertex width), and `resolution` (canvas resolution as `[width, height]`). The `bindGroups` parameter is an array of user bind groups for groups 1, 2, etc.

    #### `gpuLines.getBindGroupLayout(index)`

    Returns the bind group layout for the specified group index. Use this to create bind groups for your data.

    ```javascript
    const dataBindGroup = device.createBindGroup({
      layout: gpuLines.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: { buffer: positionBuffer } },
        { binding: 1, resource: { buffer: viewMatrixBuffer } }
      ]
    });

    const pass = encoder.beginRenderPass({ ... });
    gpuLines.draw(pass, {
      vertexCount: points.length,
      width: 20,
      resolution: [canvas.width, canvas.height]
    }, [dataBindGroup]);
    pass.end();
    ```
  </script>
  <script id="36" type="text/markdown">
    ### Position Data Format

    Your vertex function returns a `vec4f` position. The `x` and `y` components are position in clip space (-1 to 1), `z` is depth, and `w` should be `1` for valid points or `0` (or NaN for any component) for line breaks.

    Example with a storage buffer.
    ```javascript
    const positions = new Float32Array([
      x0, y0, z0, w0,  // Point 0
      x1, y1, z1, w1,  // Point 1
      // ...
    ]);

    const buffer = device.createBuffer({
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(buffer, 0, positions);
    ```

    Your `getVertex` function can read from any source (buffers, textures, procedural) and transform to clip space however you like.
  </script>
  <script id="37" type="text/markdown">
    ---

    ### Export Images

    Download all demo images for documentation.
  </script>
  <script id="38" type="module">
    function downloadURI(uri, filename) {
      const link = document.createElement("a");
      link.target = '_blank';
      link.download = filename;
      link.href = uri;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function downloadAllImages() {
      const canvases = document.querySelectorAll('canvas[id^="demo-"]');
      Array.from(canvases).forEach((canvas, i) => {
        setTimeout(() => {
          const uri = canvas.toDataURL('image/png');
          const filename = canvas.id.replace('demo-', '') + '.png';
          downloadURI(uri, filename);
        }, i * 300);
      });
    }

    const btn = html`<button style="padding: 8px 16px; cursor: pointer;">Download All Demo Images</button>`;
    btn.onclick = downloadAllImages;
    display(btn);
  </script>
</notebook>
